# Day 4: Printing Department

[Link to puzzle](https://adventofcode.com/2025/day/4)  
[Link to solution](/src/bin/04.rs)

In this puzzle we're basically working with a 2D grid of booleans. Usually I would use either a 
HashSet<Pos> a Vec<Vec<<bool>> but I figured that since the grid size is known and won't change, 
I can use a single array which makes lookups slightly faster.

To go from a coordinate to an index, you can do `y * width + x`, so that indices are arranged as such:

```
x =     0   1   2   3   4
       ___________________
y = 0 | 0   1   2   3   4  
    1 | 5   6   7   8   9
    2 | 10  11  12  13  14 
```

## Input parsing
1. First, remove trailing line breaks. Probably not needed but better safe than sorry
2. Split the input into separate lines
3. Store the length of the first line as width of the grid
4. Store the remaining number of lines (+1) as height of the grid
5. The total number of elements is `width * height`, we can pre-allocate the array using this information
6. Then per line (first line separate because we extracted it earlier), iterate over the bytes and map it to a boolean value
   based on whether the character is `@` or not.
    NOTE: I use u8 instead of bool because a Vec<bool> is bit packed which might use less memory, but 
    is apparently more expensive when doing many modifications (which is what we're doing in part 2). 
    I'm not memory constrained so u8 is fine to get some nice compiler and CPU optimizations.
7. Return the vector with presences, as well as width and height which we need for calculating indices at later points.

## Neighbor calculation
TODO

## Part 1
TODO

## Part 2
TODO
