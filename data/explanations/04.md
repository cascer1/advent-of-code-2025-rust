# Day 4: Printing Department

[Link to puzzle](https://adventofcode.com/2025/day/4)  
[Link to solution](/src/bin/04.rs)

In this puzzle we're basically working with a 2D grid of booleans. Usually I would use either a 
HashSet<Pos> a Vec<Vec<<bool>> but I figured that since the grid size is known and won't change, 
I can use a single array which makes lookups slightly faster.

To go from a coordinate to an index, you can do `y * width + x`, so that indices are arranged as such:

```
x =     0   1   2   3   4
       ___________________
y = 0 | 0   1   2   3   4  
    1 | 5   6   7   8   9
    2 | 10  11  12  13  14 
```

## Input parsing
1. First, remove trailing line breaks. Probably not needed but better safe than sorry
2. Split the input into separate lines
3. Store the length of the first line as width of the grid
4. Store the remaining number of lines (+1) as height of the grid
5. The total number of elements is `width * height`, we can pre-allocate the array using this information
6. Then per line (first line separate because we extracted it earlier), iterate over the bytes and map it to a boolean value
   based on whether the character is `@` or not.
    NOTE: I use u8 instead of bool because a Vec<bool> is bit packed which might use less memory, but 
    is apparently more expensive when doing many modifications (which is what we're doing in part 2). 
    I'm not memory constrained so u8 is fine to get some nice compiler and CPU optimizations.
7. Return the vector with presences, as well as width and height which we need for calculating indices at later points.

## Neighbor calculation
The core of both part 1 and part 2 of the puzzle revolves around checking how many slots adjacent to
a given position are occupied. For this I simply iterate over all occupied slots (there is no point
in checking empty slots) and then for those iterating over every adjacent slot (8 in total).

The `neighbors()` function takes the current coordinates and grid stats (for index calculations)
and then uses `NEIGHBOR_OFFSETS` to find the positions (and thus indices) of adjacent slots.

Then, we eliminate the ones that exceed the grind boundaries before running the supplied
function on the remaining options.

The reason for the closure instead of passing back a list of neighbors is that this way we
don't need to allocate a vector for the result, nor context switch into and out of the function.

## Part 1
Part 1 revolves around calculating how many slots have fewer than four occupied slots around them.

This is done by iterating over all slots (occupied or not) and calculating how many neighbors they have
if they themselves are occupied (we don't care about neighbors of empty slots). 

So inside the loop for the grid, we run the `neighbors()` function and simply increment neighbor count every
time one of the neighbor slots is occupied. Then, if neighbor count is less than 4, we increment
the number of accessible slots.

## Part 2
In part 2 we continue calculating accessible slots and emptying them until in the end we have no more
accessible slots. The first difference with part 1 is that instead of simply counting the number
of available slots, we store the number of neighbors per occupied slot. Additionally, if any of
the checked slots already has fewer than 4 neighbors, we immediately add it to the removal queue.

Next, we iterate over a loop so long as the removal queue is longer than the number of removed elements.

For ever iteration, we take the next item in the queue, check if it's occupied (if not we can short circuit)
and if so, we empty it. Then, we go over its neighbors and decrement each of their neighbor counts by one
(because we just removed one of them). If the neighbor count is now less than 4, we add it to the removal queue.
